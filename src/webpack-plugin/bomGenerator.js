/*
 * This file is part of CycloneDX Webpack plugin.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */

const path = require('path')
const readPkgUp = require('read-pkg-up')
const { PackageURL } = require('packageurl-js')
const parsePackageJsonName = require('parse-packagejson-name')
const Bom = require('@cyclonedx/bom/model/Bom')
const Component = require('@cyclonedx/bom/model/Component')
const Dependency = require('@cyclonedx/bom/model/Dependency')
const Metadata = require('@cyclonedx/bom/model/Metadata')
const Tool = require('@cyclonedx/bom/model/Tool')
const program = require('../../package.json')

/**
 * Create a CycloneDX SBOM from stats modules generated by webpack
 *
 * @param {any[]} modules modules from webpack
 * @param {any} defaultModule fallback module to generate if webpack found no dependencies (the root module)
 *
 * @returns {Bom} bom generated from webpack modules
 */
const resolveComponents = async function (modules = [], defaultModule = {}) {
  /**
   * Construct an SBOM using the webpack stats modules
   *
   * @param {Bom} bom the dependency tree to populate
   */
  const buildBom = async function (bom) {
    const bomRefLookup = []
    const requiredByLookup = {}

    for (const moduleData of modules) {
      /**
       * Dependencies that are from node or listed in the `externals` portion of your webpack config
       * will not be included in the dependency manifest.
       *
       * https://webpack.js.org/configuration/externals/
       */
      if (!moduleData.issuer || !moduleData.resource) {
        continue
      }

      const { issuer: { resource: requester }, resource: dependency } = moduleData
      const ignoredMatcher = /^ignored|^external|^data:/g
      // If there's no requester or the dependency or requester is ignored or marked as external by webpack
      // or issue #45 dependency is a `data:`-url containing an image or ?
      // then this dependency is skipped.
      if (!requester || !dependency || ignoredMatcher.test(requester) || ignoredMatcher.test(dependency)) { continue }

      // Get the requester package.json and dependency package.json
      let requesterPkg, dependencyPkg
      try {
        requesterPkg = await readPkgUp({ cwd: path.dirname(requester) })
        while (requesterPkg && !requesterPkg.package.name) {
          // some packages include partial package.json files in sub directories  (e.g. only containing type=module)
          requesterPkg = await readPkgUp({ cwd: path.resolve(path.dirname(requesterPkg.path), '../') })
        }

        dependencyPkg = await readPkgUp({ cwd: path.dirname(dependency) })
        while (dependencyPkg && !dependencyPkg.package.name) {
          // some packages include partial package.json files in sub directories (e.g. only containing type=module)
          dependencyPkg = await readPkgUp({ cwd: path.resolve(path.dirname(dependencyPkg.path), '../') })
        }
      } catch (err) {
        // eslint-disable-next-line no-console
        console.info(err)
      }

      if (requesterPkg && dependencyPkg) {
        /* eslint-disable-next-line no-unused-vars */
        const { package: requesterPackage, path: requesterPath } = requesterPkg
        const { package: dependencyPackage, path: dependencyPath } = dependencyPkg

        const requesterBomRef = generateBomRef(requesterPackage)
        const dependencyBomRef = generateBomRef(dependencyPackage)

        // Find and add dependency element representing the requesting package
        let dr = findDependencyByRef(requesterBomRef)
        if (!dr) {
          dr = new Dependency(requesterBomRef)
          dr.dependencies = []
          bom.addDependency(dr)
        }
        // Find and add dependency element representing the dependency package
        let dd = findDependencyByRef(dependencyBomRef)
        if (!dd && dependencyBomRef) {
          dd = new Dependency(dependencyBomRef)
          dd.dependencies = []
          bom.addDependency(dd)
        }
        // Add the dependency relationships
        // requester -depends on-> dependency
        // dependency -is required by-> requester
        if (dd && dr && dd.ref !== dr.ref) {
          if (!dd.ref) {
            // When dd.ref is empty the resulting bom has an invalid format (null or empty entries in dependencies)
            console.info('Unable to find package info for: ' + dependency)
          } else {
            let b = false
            for (const d of dr.dependencies) {
              if (d.ref === dd.ref) b = true
            }
            if (!b) { // prevent duplicates
              dr.dependencies.push(dd)
            }
          }
        }

        // Determine 'root' module by identifying dependencies that are not required
        // by a requester or which do not have a 'node_modules' directory
        if (dd) {
          if (!requiredByLookup[dd.ref]) requiredByLookup[dd.ref] = 0
          if ((dr && dd.ref !== dr.ref) || dependencyPath.includes('node_modules')) {
            ++requiredByLookup[dd.ref]
          }
        }

        // Add the component representing the dependency package to the bom
        if (dependencyBomRef && !bomRefLookup.includes(dependencyBomRef)) {
          const component = new Component(dependencyPackage)
          bom.addComponent(component)
          bomRefLookup.push(dependencyBomRef)
        }
      }
    }

    // Retrieve the root module and add it to bom metadata
    for (const key in requiredByLookup) {
      const value = requiredByLookup[key]
      if (value === 0) {
        // eslint-disable-next-line no-console
        console.info('CycloneDX: Identified root module as: ' + key)
        const tempComponents = []
        for (let i = 0; i < bom.components.length; i++) {
          if (bom.components[i].bomRef === key) {
            bom.metadata.component = bom.components[i]
          } else {
            tempComponents.push(bom.components[i])
          }
        }
        bom.components = tempComponents
        break
      }
    }
  }

  const findDependencyByRef = function (ref) {
    if (bom.dependencies) {
      for (const dependency of bom.dependencies) {
        if (dependency.ref === ref) {
          return dependency
        }
      }
    }
    return undefined
  }

  const generateBomRef = function (pkg) {
    const pkgIdentifier = parsePackageJsonName(pkg.name)
    let group = (pkgIdentifier.scope) ? pkgIdentifier.scope : undefined
    if (group) group = '@' + group
    const name = (pkgIdentifier.fullName) ? pkgIdentifier.fullName : undefined
    const version = (pkg.version) ? pkg.version : undefined
    if (name) {
      return new PackageURL('npm', group, name, version, null, null).toString()
    }
  }

  const bom = new Bom()
  const tool = new Tool('CycloneDX', 'webpack-plugin', program.version)
  const metadata = new Metadata()
  metadata.tools = [tool]
  bom.metadata = metadata

  await buildBom(bom)
  return bom
}

module.exports = { resolveComponents }
