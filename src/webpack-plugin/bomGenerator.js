/*
 * This file is part of CycloneDX Webpack plugin.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
const readPkgUp = require('read-pkg-up');
const { PackageURL } = require('packageurl-js');
const parsePackageJsonName = require('parse-packagejson-name');
const Bom = require('@cyclonedx/bom/model/Bom');
const Component = require('@cyclonedx/bom/model/Component');
const Dependency = require('@cyclonedx/bom/model/Dependency');
const Metadata = require('@cyclonedx/bom/model/Metadata');
const Tool = require('@cyclonedx/bom/model/Tool');
const program = require('../../package.json');

/**
 * Create a CycloneDX SBOM from stats modules generated by webpack
 * @param {any[]} modules modules from webpack
 * @param {any} defaultModule fallback module to generate if webpack found no dependencies (the root module)
 * @returns {Bom} bom generated from webpack modules
 */
const resolveComponents = async function(modules = [], defaultModule = {}) {

    /**
     * Construct an SBOM using the webpack stats modules
     * @param {Bom} bom the dependency tree to populate
     */
    const buildBom = async function(bom) {
        let bomRefLookup = [];
        let requiredByLookup = {};

        for (const moduleData of modules) {

            /**
             * Dependencies that are from node or listed in the `externals` portion of your webpack config
             * will not be included in the dependency manifest.
             *
             * https://webpack.js.org/configuration/externals/
             */
            if (!moduleData.issuer || !moduleData.resource) {
                continue;
            }

            const {issuer: {resource: requester}, resource: dependency} = moduleData;
            const ignoredMatcher = /^ignored|^external/g;
            // If there's no requester or the dependency or requester is ignored or marked as external by webpack
            // then this dependency is skipped.
            if (!requester || !dependency || ignoredMatcher.test(requester) || ignoredMatcher.test(requester))
                continue;

            // Get the requester package.json and dependency package.json
            let requesterPkg, dependencyPkg;
            try {
                requesterPkg = await readPkgUp({cwd: requester});
                dependencyPkg = await readPkgUp({cwd: dependency});
            } catch (err) {
                // eslint-disable-next-line no-console
                console.info(err);
            }

            if (requesterPkg && dependencyPkg) {
                const {package: requesterPackage, path: requesterPath} = requesterPkg;
                const {package: dependencyPackage, path: dependencyPath} = dependencyPkg;

                let requesterBomRef = generateBomRef(requesterPackage);
                let dependencyBomRef = generateBomRef(dependencyPackage);

                // Find and add dependency element representing the requesting package
                let dr = findDependencyByRef(requesterBomRef);
                if (!dr) {
                    dr = new Dependency(requesterBomRef);
                    dr.dependencies = [];
                    bom.addDependency(dr);
                }
                // Find and add dependency element representing the dependency package
                let dd = findDependencyByRef(dependencyBomRef);
                if (!dd && dependencyBomRef) {
                    dd = new Dependency(dependencyBomRef);
                    dd.dependencies = [];
                    bom.addDependency(dd);
                }
                // Add the dependency relationships
                // requester -depends on-> dependency
                // dependency -is required by-> requester
                if (dd && dr && dd._ref !== dr._ref) {
                    let b = false;
                    for (let d of dr._dependencies) {
                        if (d._ref === dd._ref) b = true;
                    }
                    if (!b) { // prevent duplicates
                        dr._dependencies.push(dd);
                    }
                }

                // Determine 'root' module by identifying dependencies that are not required
                // by a requester or which do not have a 'node_modules' directory
                if (dd && !requiredByLookup[dd._ref]) requiredByLookup[dd._ref] = 0;
                if (dd && dr && dd._ref !== dr._ref || dependencyPath.includes("node_modules")) {
                    if (dd) {
                        requiredByLookup[dd._ref]++;
                    }
                }

                // Add the component representing the dependency package to the bom
                if (dependencyBomRef && !bomRefLookup.includes(dependencyBomRef)) {
                    let component = new Component(dependencyPackage);
                    bom.addComponent(component);
                    bomRefLookup.push(dependencyBomRef);
                }
            }
        }

        // Retrieve the root module and add it to bom metadata
        for (let key in requiredByLookup) {
            let value = requiredByLookup[key];
            if (value === 0) {
                // eslint-disable-next-line no-console
                console.info("CycloneDX: Identified root module as: " + key);
                let tempComponents = []
                for (let i=0; i<bom.components.length; i++) {
                    if (bom.components[i].bomRef === key) {
                        bom.metadata.component = bom.components[i];
                    } else {
                        tempComponents.push(bom.components[i]);
                    }
                }
                bom.components = tempComponents;
                break;
            }
        }
    };

    const findDependencyByRef = function (ref) {
        if (bom.dependencies) {
            for (let dependency of bom.dependencies) {
                if (dependency.ref === ref) {
                    return dependency;
                }
            }
        }
        return undefined;
    }

    const generateBomRef = function (pkg) {
        let pkgIdentifier = parsePackageJsonName(pkg.name);
        let group = (pkgIdentifier.scope) ? pkgIdentifier.scope : undefined;
        if (group) group = '@' + group;
        let name = (pkgIdentifier.fullName) ? pkgIdentifier.fullName : undefined;
        let version = (pkg.version) ? pkg.version : undefined;
        if (name) {
            return new PackageURL('npm', group, name, version, null, null).toString();
        }
    }

    const bom = new Bom();
    let tool = new Tool("CycloneDX", "webpack-plugin", program.version);
    let metadata = new Metadata();
    metadata.tools = [tool];
    bom.metadata = metadata;

    await buildBom(bom);
    return bom;
};

module.exports = {resolveComponents};
